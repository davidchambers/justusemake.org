#!/usr/bin/env node

'use strict';


var input = '';
process.stdin.setEncoding('utf8');
process.stdin.on('readable', function() { input += process.stdin.read(); });
process.stdin.on('end', function() { process.stdout.write(decorate(input, '', [])); });


var functionNames = [
  'abspath', 'addprefix', 'addsuffix', 'and', 'basename', 'call', 'dir',
  'error', 'eval', 'file', 'filter', 'filter-out', 'findstring', 'firstword',
  'flavor', 'foreach', 'guile', 'if', 'info', 'join', 'lastword', 'notdir',
  'or', 'origin', 'patsubst', 'realpath', 'shell', 'sort', 'strip', 'subst',
  'suffix', 'value', 'warning', 'wildcard', 'word', 'wordlist', 'words',
];

var targetNames = [
  '.DEFAULT', '.DELETE_ON_ERROR', '.EXPORT_ALL_VARIABLES', '.IGNORE',
  '.INTERMEDIATE', '.LOW_RESOLUTION_TIME', '.NOTPARALLEL', '.ONESHELL',
  '.PHONY', '.POSIX', '.PRECIOUS', '.SECONDARY', '.SECONDEXPANSION',
  '.SILENT', '.SUFFIXES',
];

var matchGroupBegin =
  new RegExp('^([$][({])(?:(' + functionNames.join('|') + ')(?= ))?([\\s\\S]*)$');

var matchTargetName =
  new RegExp('^((?:' + targetNames.join('|') + '):)([\\s\\S]*)$');

var decorate = function recur(input, output, stack) {
  var $;
  if (input === '') {
    return output;
  } else if (/^$|\n$/.test(output) && (stack == '' || stack == '\t') && ($ = /^(\s*)(#.*)([\s\S]*)$/.exec(input))) {
    return recur($[3], output + $[1] + wrap('comment', $[2]), stack);
  } else if (/^$|\n$/.test(output) && ($ = matchTargetName.exec(input))) {
    return recur($[2], output + wrap('target', $[1]), stack);
  } else if (/^$|\n$/.test(output) && stack == '' && ($ = /^\t([\s\S]*)$/.exec(input))) {
    return recur($[1], output + open('recipe') + '\t', concat(stack, ['\t']));
  } else if (last(stack) === '\t' && /\t$/.test(output) && ($ = /^@([\s\S]*)$/.exec(input))) {
    return recur($[1], output + wrap('silent', '@'), stack);
  } else if (last(stack) === "'" && ($ = /^'([\s\S]*)$/.exec(input))) {
    return recur($[1], output + "'" + close(), butlast(stack));
  } else if (last(stack) === '"' && ($ = /^"([\s\S]*)$/.exec(input))) {
    return recur($[1], output + '"' + close(), butlast(stack));
  } else if (last(stack) === '$(' && ($ = /^[)]([\s\S]*)$/.exec(input))) {
    return recur($[1], output + ')' + close(), butlast(stack));
  } else if (last(stack) === '${' && ($ = /^[}]([\s\S]*)$/.exec(input))) {
    return recur($[1], output + '}' + close(), butlast(stack));
  } else if (last(stack) === '\t' && ($ = /^\n(?!\t)([\s\S]*)$/.exec(input))) {
    return recur($[1], output + close() + '\n', butlast(stack));
  } else if (($ = /^('|")([\s\S]*)$/.exec(input))) {
    return recur($[2], output + open('string') + $[1], concat(stack, [$[1]]));
  } else if (($ = matchGroupBegin.exec(input))) {
    return recur($[3], output + open('group') + $[1] + ($[2] ? wrap('function', $[2]) : ''),
                 concat(stack, [$[1]]));
  } else if (($ = /^([$][@%<?^+|*])([\s\S]*)$/.exec(input))) {
    return recur($[2], output + wrap('auto-var', $[1]), stack);
  } else {
    return recur(input.slice(1), output + escape(input[0]), stack);
  }
};

// concat :: [a],[a] -> [a]
function concat(listA, listB) {
  return listA.concat(listB);
}

// escape :: String -> String
function escape(text) {
  return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

// last :: [a] -> a
function last(list) {
  return list[list.length - 1];
}

// butlast :: [a] -> [a]
function butlast(list) {
  return list.slice(0, -1);
}

// open :: String -> String
function open(className) {
  return '<span class="' + className + '">';
}

// close :: -> String
function close() {
  return '</span>';
}

// wrap :: String,String -> String
function wrap(className, text) {
  return open(className) + escape(text) + close();
}
